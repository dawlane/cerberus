#Rem
This file is for additional functions to assist in the manipulation of building projects.
Change Log
----------------------------------------------------------------------------------------------
2018-10-04 - Dawlane
					Reintroduced path checks for directory searching and updated the method to display the output.
					Use #SHOW_SEARCH_PATH_CHECK in a source file to show search directories and evaluations.
2018-09-23 - Dawlane
					Added a function to try to get the version of GCC. Linux only for now.
2018-08-26 - Dawlane
					Removed path checks for directory searching.
2018-08-02 - Dawlane
					Added a function to execute external applications and return information from stdout and stderr.
					Makes use of cpp code in the native folder.
#End

Import transcc
Import os
Import "native/exec.cpp"

' DAWLANE ADDED FUNCTIONS START
Extern
	Function ExecutePipe( cmd$, ref$ )
Public

' Add quote around a string
Function QuoteMe:String( str:String )
	Return "~q"+str+"~q"
End

' Function to create -L/ISearchPaths
Function DefineGCCPaths:String( paths:String, option:String, quote:Bool=False, configStr:String="", showOutput:Bool=False )
	Local splits:String[]=paths.Split( ";" )
	Local str:="", truePath:=""
	
	If showOutput Print "Evaluating: "+configStr
	For Local i:=0 Until splits.Length()
		truePath=RealPath( splits[i] )
		If quote str+=" -"+option+"~q"+truePath+"~q " Else str+=" -"+option+truePath+" "
		If showOutput Print "-"+option+"~q"+truePath+"~q"
	Next
	Return str[ .. ( str.Length()-1 ) ]
End

' Parse a string to look for any preprocessor directives to expand.
Function MacroExpansion:String[]( search:String[], showOutput:Bool=False )	
	Local configVars:= GetConfigVars()
	
	Local f:Int, l:Int, i:Int, idx:Int, b:Int
	For idx = 0 Until search.Length()
		' Search the string
		i=0
		While i < search[idx].Length()
			f = search[idx].Find( "#{", i )
			' Found the start of a macro if the value is greater than -1
			If f>-1
				l = search[idx].Find( "}", f ) ' End brace
				If showOutput Print "~nMarco search of line: "+search[idx]
				' Found a last bracket for the macro
				If l>-1
					' Check that there are no other starting braces
					b = search[idx].Find( "#{", f+1 )
					If b>-1
						if b<l Die "Macro Syntax Error: Start brace before end brace for "+search[idx][ f+2 .. l  ]
					endif
					Local val:= configVars.Get( search[idx][ f+2 .. l  ] )
					If showOutput Print "Macro Found: >"+search[idx][ f+2 .. l ]+"<"
					If val<>""
						search[idx] = search[idx].Replace( search[idx][ f .. l+1 ], val )
						If showOutput Print "Evaluated: "+search[idx]
						i+=val.Length()
					Else
						' Not a macro, so add the length to skip it
						Die "Macro >"+search[idx][ f+2 .. l ]+"< Not Recognised"
						i = f+l+1
					Endif
				Else
					' No end brace, so stop execution.
					If b>-1 Die "Macro Syntax Error: No ending brace for "+search[idx][ f+2 .. l  ]
				Endif	
			Else
				' No starting brace, so just move a long one character
				i+=1
			Endif
		Wend
	Next
	Return search
End Function

' Function generate search paths based on the strings passed
Function GenerateSearchPaths:String( paths:String, prjRoot:String, prjTemplate:String, cerbRoot:String, configStr:String="", showOutPut:Bool=False, quote:Bool=False )
	Local store:= New StringStack()
	Local searchP:String[]=MacroExpansion( paths.Split( ";" ), showOutPut )
	Local i:Int, j:Int, out:="", sepa:Bool=False
	
	If showOutPut Print "~nGenerating search paths for: "+configStr
	
	For i = 0 Until searchP.Length()
		sepa=False
		' First check against prjRoot
		If FileType( RealPath( prjRoot+"/"+searchP[i] ) ) = FILETYPE_DIR
			If Not store.Contains( RealPath( prjRoot+"/"+searchP[i] ) ) store.Push( RealPath( prjRoot+"/"+searchP[i] ) )
			If showOutPut Print "Project Root Stored: "+RealPath( prjRoot+"/"+searchP[i] ); sepa=True
		Endif

		' Second check against prjTemplate
		If FileType( RealPath( prjTemplate+"/"+searchP[i] ) ) = FILETYPE_DIR
			If Not store.Contains( RealPath( prjTemplate+"/"+searchP[i] ) ) store.Push( RealPath( prjTemplate+"/"+searchP[i] ) )
			If showOutPut Print "Project Template Stored: "+RealPath( prjTemplate+"/"+searchP[i] ); sepa=True
		Endif
		
		' Third check against cerbRoot. Should in theory allow you to have named sub directories within the cerberus libs directory without using the full path name.
		For j = 0 Until cerbRoot.Length()
			If FileType( RealPath(  cerbRoot+"/"+searchP[i] ) ) = FILETYPE_DIR
				If Not store.Contains( RealPath(  cerbRoot+"/"+searchP[i] ) )
					store.Push( RealPath(  cerbRoot+"/"+searchP[i] ) )
					If showOutPut Print "Cerberus Root Stored: "+RealPath( cerbRoot+"/"+searchP[i] ); sepa=True
				Endif
			Endif
		Next
		
		' Fourth check that the path doesn't already exist
		If FileType( RealPath( searchP[i] ) ) = FILETYPE_DIR
			If Not store.Contains( RealPath( searchP[i] ) ) store.Push( RealPath( searchP[i] ) )
			If showOutPut Print "Full Path Stored: "+RealPath( searchP[i] ); sepa=True
		Endif
		If showOutPut
			If sepa Print "------------------------------------"
		Endif
	Next
	
	' Rebuild a search string
	For Local s:=Eachin store
		If Not quote out+=s+";" Else out+=QuoteMe( s )+";" 
	Next
	out=out[ .. ( out.Length()-1 ) ]
	Return out
End

' Copy over any licence directories
Function CopyLicences( buildconfig:String, targetOS:String, srcPath:String , arch:String="")

	Local licence:String=GetConfigVar( "COPY_LICENCES" )
	If licence="" Return
	
	Local dst:="", src:="", ext:="", lidst:=""
	Local licenceList:String[]=licence.Split( ";" )
	
	' Set the destination for dynamic libraries
	Select targetOS
		Case "gcc", "wint"
			dst=buildconfig+arch+"/"
		Case "macos"
			dst=buildconfig+"/"
	End
	
	Print "Licence destination: "+dst
	Print "Licence source: "+srcPath
	' Create a directory for licence files
	If Not FileType( dst+"licences" ) Then CreateDir( dst+"licences" )
	
	' Copy the licence directories
	
	For Local i:= Eachin licenceList
		If i<>""
			
			If FileType( dst+"licences/"+i )=FILETYPE_DIR Continue
	
			' Copy licences related to copying e.g. LGPL stuff
			If FileType( srcPath+"/licences/"+i )<>FILETYPE_NONE
				If CopyDir( srcPath+"/licences/"+i, dst+"licences/"+i, True )=1
					Print "Copied licence directory"
				Else
					Print "Failed to copy licence directory"
				Endif
			Endif

		EndIf
	Next
End

' Cheat just copy over the icon and delete any old resource files
Function CopyICON:Int( userPath:String = "icon", extension:String, prjPath:String, target:String, cerbPath:String, resourceFile:String )
	Local userFile:=userPath+"."+extension
	Local targetFile:=target+"/icon."+extension
	If DeleteFile( resourceFile ) Print "Deleted Resource file "+resourceFile Else Print "WARNING: Failed to remove old resource file from "+resourceFile
	' Look in the user defined full path first for the icon file.
	If FileType( userFile )=FILETYPE_FILE
		' The file exists, so copy that over
		Print "Copying icon from project "+userFile+" directory To "+targetFile
		Return CopyFile( userFile, targetFile ) ' Should return 1 if all went well
	Else
		' The file wasn't a full path, so now check the local icons project directory
		If FileType( prjPath+"icons/"+userFile )=FILETYPE_FILE
			Print "Copying icon "+userFile+" from project resource directory ("+prjPath+"icons) To "+targetFile
			Return CopyFile( prjPath+"icons/"+userFile, targetFile ) ' Should return 1 if all went well
		Else
		' If it's not in the users icon resource directory, then fallback to the cerberus one
			Print "Copying icon from Cerberus resource directory to "+targetFile
			Return CopyFile( cerbPath+"/src/archives/icons/cerberus."+extension, targetFile ) ' Should return 1 if all went well
		Endif
	Endif
End Function

' Detect GCC versions. May move a version of this into all GCC makefiles.
Function GCCVer:String[]()
	Local ret:String[]
	Select HostOS()
		Case "linux"
			Local str:=""
			Local err:=ExecutePipe( "expr `gcc -dumpfullversion | sed -e 's/^[ \t]*//'`", str )	' GCC 6+ should support this.
			If err<>0 str=""; ExecutePipe( "expr `gcc -dumpversion | sed -e 's/^[ \t]*//'`", str )
			ret=str.Split(".")
			Return ret
		Case "winnt"
			Local str:=""
			Local err:=ExecutePipe( "gcc -dumpfullversion", str )	' GCC 6+ should support this.
			If err<>0
				err=ExecutePipe( "gcc -dumpversion", str )
				If err<>0 str="UNKNOWN"
			Endif
			ret=str.Split(".")
			Return ret
	End Select
	Return ret
End Function


Function CreateDefaultDirs:Void( cerberusdir:String, msize:String, gccVersion:String[], vs_version:String = "" )
	' Not get the version of the GCC compiler being used and store it as a config variable for later use if required later.
		' E.G. If it's decided that the locations of GCC libraries need to be separated, just like Visual Studio.
		' Also make sure that the default directories exist or there could be trouble passing those paths to search.
		
		Select HostOS()
			Case "winnt"
				If gccVersion.Length>0
					Print "Using MinGW Version "+gccVersion[0]+"."+gccVersion[1]+"."+gccVersion[2]
					SetConfigVar "GLFW_GCC_VERSION_WINNT",gccVersion[0]+"."+gccVersion[1]+"."+gccVersion[2]
				Endif
				CreateDir( RealPath( cerberusdir+"/libs/shared/Win"+msize ) )
				CreateDir( RealPath( cerberusdir+"/libs/static/MinGW/"+msize ) )
				CreateDir( RealPath( cerberusdir+"/includes" ) )
				CreateDir( RealPath( cerberusdir+"/libs/shared/Win"+msize ) )
				CreateDir( RealPath( cerberusdir+"/libs/static/VisualStudio/"+vs_version+"/"+msize ) )
			Case "linux"
				If gccVersion.Length>0
					Print "Using GCC Version "+gccVersion[0]+"."+gccVersion[1]+"."+gccVersion[2]
					SetConfigVar "GLFW_GCC_VERSION_LINUX",gccVersion[0]+"."+gccVersion[1]+"."+gccVersion[2]
				Endif
				CreateDir( RealPath( cerberusdir+"/libs/shared/Linux"+msize ) )
				CreateDir( RealPath( cerberusdir+"/libs/static/Linux/"+msize ) )
				CreateDir( RealPath( cerberusdir+"/includes" ) )
			Case "macos"
				CreateDir( RealPath( cerberusdir+"/libs/shared/MacOS" ) )
				CreateDir( RealPath( cerberusdir+"/libs/shared/MacOS/Frameworks" ) )
				CreateDir( RealPath( cerberusdir+"/libs/static/MacOS" ) )
				CreateDir( RealPath( cerberusdir+"/includes" ) )
		End
End Function
' DAWLANE ADDED FUNCTIONS END 

